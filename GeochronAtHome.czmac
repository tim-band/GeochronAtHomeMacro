<?xml version="1.0" encoding="utf-8"?>
<Script>
  <Context>Zen26</Context>
  <Version>1.0</Version>
  <Language>Python</Language>
  <Text># Getting data for Geochron@Home
# Data:
# 1. Folder for the data
# 2. POI file
# 3. Tiled circularly polarized light image of minerals
# 4. Tiled transmitted light image of mica (if applicable)
# 5. Mineral to mica matrix file (if applicable)
# 6. Mineral Z-stacks
# 7. Mica Z-stacks
# 8. Dosimeter images (images sampled from mica with known area marked)
#
# Actions:
# Add registration points [r] (1 -&gt; 2a)
# Add mineral extent points [x] (1 -&gt; 2b)
# Add mica extent points [m] (1 -&gt; 2c)
# Create mineral tiled image (1,2b -&gt; 3)
# Create mica tiled image (1,2c -&gt; 4)
# Launch Manimal for matrix (1,3,4 -&gt; 5)
# Launch Manimal for POIs [r,i] (1,3 -&gt; 2)
# Reregister POIs (2a,2? -&gt; 2a,2?)
# Fix POIs (1,2 -&gt; 2)
# Fix matrix (1,2,5 -&gt; 2(mark some unsuitable),5)
# Create mineral Z-stacks (1,2 -&gt; 6)
# Create mica Z-stacks (1,2,5 -&gt; 7)
# Capture dosimeter images from mica (2c -&gt; 8)
# Exit

import glob
import linear
import math
import os
import random
import subprocess
import time
import workarounds

reload(workarounds)
reload(linear)

import clr

clr.AddReference('System.Windows.Forms')

from System.Windows.Forms import (
    AnchorStyles, Application, AutoSizeMode,
    Form, Label, ListBox, TableLayoutPanel,
    PictureBox, PictureBoxSizeMode, ProgressBar,
    TextBox, ScrollBars
)
from System import (Environment)

zen = workarounds.Workarounds(Zen, Zeiss)

def resource_location(name):
    return os.path.join(
        Zen.Application.Environment.GetFolderPath(ZenSpecialFolder.UserDocuments),
        'Macros',
        'GeochronAtHome',
        name
    )

tile_tl_experiment_name = resource_location('TileTL.czexp')
tile_rl_experiment_name = resource_location('TileRL.czexp')
tile_cpol_experiment_name = resource_location('TileCPol.czexp')
fine_focus_experiment_name = resource_location('FocusRL.czexp')
coarse_focus_experiment_name = resource_location('FocusRLCoarse.czexp')
map_experiment_name = resource_location('MapTL.czexp')

# For some reason, hardware settings don't work in other directories
hs_reflected = 'Reflected'
hs_transmitted = 'Transmitted'
camera_setting = '100ms'

class UserCancelledException(Exception):
    pass

class ProgressOutput(Form):
    def __init__(self, count):
        super(ProgressOutput, self).__init__()
        width = 450
        self.Text = "Progress"
        self.AutoSize = True
        self.AutoSizeMode = AutoSizeMode.GrowAndShrink
        self.layout = TableLayoutPanel()
        self.layout.AutoSize = True
        self.layout.AutoSizeMode = AutoSizeMode.GrowAndShrink
        self.Controls.Add(self.layout)
        self.progress = ProgressBar()
        self.progress.Maximum = count
        self.progress.Step = 1
        self.progress.Width = width
        self.layout.Controls.Add(self.progress, 0, 0)
        self.current = TextBox()
        self.current.ReadOnly = True
        self.current.Width = width
        self.layout.Controls.Add(self.current, 0, 1)
        self.etaLabel = Label()
        self.etaLabel.Text = "estimated finish time:"
        self.etaLabel.Width = width
        self.layout.Controls.Add(self.etaLabel, 0, 2)
        self.eta = TextBox()
        self.eta.ReadOnly = True
        self.eta.Width = width
        self.layout.Controls.Add(self.eta, 0, 3)
        self.failLabel = Label()
        self.failLabel.Text = "failures:"
        self.failLabel.Width = width
        self.layout.Controls.Add(self.failLabel, 0, 4)
        self.failures = TextBox()
        self.failures.ReadOnly = True
        self.failures.Multiline = True
        self.failures.Width = width
        self.failures.Height = 140
        self.failures.ScrollBars = ScrollBars.Vertical
        self.layout.Controls.Add(self.failures, 0, 5)
        self.in_task = False
        self.TopMost = True
        self.start_time = time.time()
        self.start_clock = time.clock()
        self.Show()
    def result(self):
        return self.combo.SelectedItem
    def close(self):
        self.Close()
        self.Dispose()
    def start(self, name):
        self.current.Text = name
        self.in_task = True
    def stop(self, success):
        if not self.in_task:
            return
        self.in_task = False
        self.progress.PerformStep()
        duration = time.clock() - self.start_clock
        eta = self.start_time + duration / self.progress.Value * self.progress.Maximum
        self.eta.Text = time.strftime('%H:%M', time.localtime(eta))
        if not success:
            if 0 &lt; len(self.failures.Text):
                self.failures.Text += Environment.NewLine
            self.failures.Text += self.current.Text

class SelectForm(Form):
    def __init__(self, title, label, options):
        super(SelectForm, self).__init__()
        self.Text = title
        self.AutoSize = True
        self.AutoSizeMode = AutoSizeMode.GrowAndShrink
        self.layout = TableLayoutPanel()
        self.layout.AutoSize = True
        self.layout.AutoSizeMode = AutoSizeMode.GrowAndShrink
        self.Controls.Add(self.layout)
        self.label = Label()
        self.label.Text = label
        self.label.Width = 140
        self.label.Height = 80
        self.layout.Controls.Add(self.label, 0, 0)
        self.combo = ListBox()
        for s in options:
            self.combo.Items.Add(s)
        self.combo.SetSelected(0, True)
        self.combo.AutoSize = True
        self.layout.Controls.Add(self.combo, 1, 0)
        self.TopMost = True
    def show(self):
        self.Show()
    def result(self):
        return self.combo.SelectedItem
    def close(self):
        self.Close()
        self.Dispose()

def removeNones(array):
    return [x for x in array if x]

class AdjustForm(SelectForm):
    OK = 'set to current position and focus'
    LEAVE = 'leave as it is'
    MARK = 'mark as unsuitable'
    EXIT = 'exit task'
    CHANGE = None
    EXIT_CANCEL = "don't exit, carry on adjusting!"
    EXIT_KEEP = 'exit, leaving remaining POIs as they are'
    EXIT_MARK_ALL = 'exit and mark remaining POIs as unsuitable'
    EXIT_KEEP_ALL = 'exit, keeping all points'
    TITLE = 'Choose what should happen to this POI'
    LABEL = 'What should we do with this POI?'
    def get_prompt(self, count, total, kept):
        return (
            'Adjust position and focus ({0} of {1}) ({2} kept so far)'
            .format(count, total, kept)
        )
    def __init__(self, objects):
        super(AdjustForm, self).__init__(
            self.TITLE,
            self.LABEL,
            removeNones([self.OK, self.LEAVE, self.MARK, self.EXIT, self.CHANGE])
        )
        self.objects = list(objects)
        self.total_count = len(self.objects)
        self.count = 0
        self.kept = 0
        self.action = None
        self.exiting = False
    def get_exit_action(self):
        action = 'action'
        window = Zen.Windows.CreateWindow('Exit adjustment?')
        window.AddDropDown(
            action,
            'What now?',
            removeNones([self.EXIT_CANCEL, self.EXIT_KEEP, self.EXIT_MARK_ALL, self.EXIT_KEEP_ALL]),
            0
        )
        result = zen.show_window(window)
        return result.GetValue(action)
    def try_update_adjust_action(self):
        if self.exiting:
            return True
        Zen.Application.Pause(self.get_prompt(self.count, self.total_count, self.kept))
        self.action = self.result()
        if self.action != self.EXIT:
            return True
        exit_action = self.get_exit_action()
        if exit_action == self.EXIT_MARK_ALL:
            self.exiting = True
            self.action = self.MARK
            return True
        elif exit_action == self.EXIT_KEEP:
            self.exiting = True
            self.action = self.LEAVE
            return True
        elif exit_action == self.EXIT_KEEP_ALL:
            self.action = self.EXIT
            return True
        return False
    def update_adjust_action(self):
        """
        Ask for the action repeatedly until the user stops saying "exit, keep editing"
        """
        self.show()
        while not self.try_update_adjust_action():
            pass
    def drive(self, o, count, total_count):
        pass
    def do_adjust(self, o):
        pass
    def do_mark(self, o):
        pass
    def unmark_all(self):
        pass
    def undrive(self, o):
        pass
    def change(self, o, count, total_count):
        pass
    def action_for_one_point(self, o):
        self.count += 1
        self.update_adjust_action()
        while self.action == self.CHANGE:
            self.change(o, self.count, self.total_count)
            self.update_adjust_action()
    def run(self):
        zen.show_live()
        count = 0
        self.kept = 0
        for o in self.objects:
            driven = False
            if not self.exiting:
                self.drive(o, self.count, self.total_count)
                driven = True
            self.action_for_one_point(o)
            if self.action == self.OK:
                self.do_adjust(o)
                count += 1
                self.kept += 1
            elif self.action == self.MARK:
                self.do_mark(o)
                count += 1
            elif self.action == self.LEAVE:
                self.kept += 1
            if driven:
                self.undrive(o)
            if self.action == self.EXIT:
                # User wants to exit, saving nothing
                self.unmark_all()
                return 0
        return count
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

class Poi(object):
    def __init__(self, table, row):
        self.table = table
        self.row = row
    @property
    def table_row(self):
        return self.row
    @property
    def x(self):
        return float(self.table.GetValue(self.row, 1))
    @x.setter
    def x(self, value):
        self.table.SetValue(self.row, 1, value)
    @property
    def y(self):
        return float(self.table.GetValue(self.row, 2))
    @y.setter
    def y(self, value):
        self.table.SetValue(self.row, 2, value)
    @property
    def z(self):
        return float(self.table.GetValue(self.row, 3))
    @z.setter
    def z(self, value):
        self.table.SetValue(self.row, 3, value)
    @property
    def micaZ(self):
        mz = self.table.GetValue(self.row, 5)
        if mz is None:
            return None
        try:
            return float(mz.strip())
        except ValueError:
            return None
        except AttributeError:
            return None
        except Exception as e:
            print type(e)
            print e
            return None
    @micaZ.setter
    def micaZ(self, value):
        self.table.SetValue(self.row, 5, value)
    @property
    def poi_type(self):
        return self.table.GetValue(self.row, 0)
    @property
    def name(self):
        return self.table.GetValue(self.row, 4)
    @name.setter
    def name(self, value):
        self.table.SetValue(self.row, 4, value)

def suitable_and_not_done(is_unsuitable, is_done):
    return not is_unsuitable and not is_done

def suitable(is_unsuitable, is_done):
    return not is_unsuitable

def unsuitable(is_unsuitable, is_done):
    return is_unsuitable

def all_points(is_suitable, is_done):
    return True

class Documents(object):
    def load(self, filename):
        """ Load a csv file as a table """
        return Zen.Application.LoadTable(
            os.path.join(self.folder, filename)
        )
    def save(self, table, filename):
        table.Save(os.path.join(self.folder, filename))
    def exists(self, filename):
        return os.path.exists(
            os.path.join(self.folder, filename)
        )
    def save_poi(self):
        self.save(self.poi, 'poi.csv')
    def save_matrix(self):
        self.save(self.matrix_table, 'matrix.csv')
    def save_current_matrix(self):
        self.save(self.current_matrix_table, 'current_reg_matrix.csv')
    def save_current_matrix_as(self, path):
        if self.current_matrix_table:
            self.current_matrix_table.Save(path)
    def minerals_files(self):
        pattern = os.path.join(self.folder, 'minerals*.czi')
        return glob.glob(pattern)
    def minerals_file_exists(self):
        names = self.minerals_files()
        return 0 &lt; len(names)
    def __init__(self, folder):
        self.folder = folder
        self.poi = self.load('poi.csv')
        if not self.poi:
            self.poi = ZenTable('poi.csv')
            self.poi.Columns.Add('type')
            self.poi.Columns.Add('x')
            self.poi.Columns.Add('y')
            self.poi.Columns.Add('z')
            self.poi.Columns.Add('name')
        if not self.poi.Columns.Contains('micaz'):
            self.poi.Columns.Add('micaz')
        # Transformation from minerals image to equivalent points on mica image
        self.matrix_table = self.load('matrix.csv')
        self.matrix = linear.table_to_matrix(self.matrix_table)
        # Transformation from project co-ordinates to current stage co-ordinates
        self.current_matrix_table = self.load('current_reg_matrix.csv')
        self.current_matrix = linear.table_to_matrix(self.current_matrix_table)
        self.has_minerals = self.minerals_file_exists()
        self.has_mica = self.exists('mica.czi')
        self.grain_folder_number = 1
    def get_current_matrix_table(self):
        if self.current_matrix_table:
            return self.current_matrix_table
        m = ZenTable('current_reg_matrix.csv')
        m.Columns.Add('x')
        m.Columns.Add('y')
        m.Columns.Add('t')
        m.Rows.Add(1, 0, 0)
        m.Rows.Add(0, 1, 0)
        self.current_matrix_table = m
        self.current_matrix = linear.table_to_matrix(m)
        return m
    def maybe_current_matrix(self):
        if not self.current_matrix_table:
            return None
        return 'current_reg_matrix.csv'
    def get_pois(self, type='i', suitability_function=suitable_and_not_done):
        for i in range(self.poi.RowCount):
            name = self.poi.GetValue(i,4)
            if name != '' and name[0] != '#' and not os.path.exists(name):
                # POI has a path but that path is no longer valid.
                # We must delete this path in case it gets recreated
                # again as another POI's path!
                self.poi.SetValue(i, 4, '')
        for i in range(self.poi.RowCount):
            t = self.poi.GetValue(i,0)
            name = self.poi.GetValue(i,4)
            is_blank = name == ''
            is_unsuitable = not is_blank and name[0] == '#'
            is_done = not is_blank and not is_unsuitable and os.path.exists(name)
            if t == type and suitability_function(is_unsuitable, is_done):
                yield Poi(self.poi, i)
    def all_pois(self):
        for i in range(self.poi.RowCount):
            yield Poi(self.poi, i)
    def drive_to_xyz(self, x, y, **kwargs):
        if self.current_matrix:
            (x,y) = linear.transform(self.current_matrix, x, y)
        zen.move_stage(x, y, **kwargs)
    def drive_to_poi(self, p):
        self.drive_to_xyz(p.x, p.y, z=p.z)
    def drive_to_poi_mica(self, p):
        (x,y) = linear.transform(self.matrix, p.x, p.y)
        self.drive_to_xyz(x, y, z=p.micaZ)
        zen.show_live()
    def stage_position(self):
        """
        returns the stage position in project coordinates
        """
        x = Zen.Devices.Stage.ActualPositionX
        y = Zen.Devices.Stage.ActualPositionY
        if self.current_matrix:
            (x,y) = linear.inv_transform(self.current_matrix, x, y)
        return (x, y, Zen.Devices.Focus.ActualPosition)
    def stage_position_of_poi(self, p):
        """
        returns the POI's position in stage coordinates
        """
        if self.current_matrix:
            return linear.transform(self.current_matrix, p.x, p.y)
        return (p.x, p.y)
    def poi_mica_position(self, p):
        """
        returns the POI's mica position in project coordinates
        """
        return linear.transform(self.matrix, p.x, p.y)
    def mica_angle(self):
        """
        Returns the angle (after mirroring) to rotate a piture
        of a mineral by to make it match a mica, in degrees clockwise.
        """
        rads = math.atan2(self.matrix[1][0], -self.matrix[0][0])
        return math.degrees(-rads)
    def delete_full_path(self, path):
        if not os.path.exists(path):
            return
        doc = Zen.Application.Documents.GetByFileName(path)
        if doc:
            doc.Close()
        os.remove(path)
    def delete(self, filename):
        path = os.path.join(self.folder, filename)
        self.delete_full_path(path)
    def delete_minerals(self):
        for n in self.minerals_files():
            self.delete_full_path(n)
        self.has_minerals = False
    def delete_mica(self):
        self.delete('mica.czi')
        self.has_mica = False
    def delete_current_matrix(self):
        self.delete('current_reg_matrix.csv')
        self.current_matrix = None
        self.current_matrix_table = None
    def get_next_grain_folder(self):
        pattern = os.path.join(self.folder, 'Grain') + '{1:02d}'
        while True:
            name = pattern.format(folder, self.grain_folder_number)
            if not os.path.exists(name):
                return name
            self.grain_folder_number += 1
    def load_mica_surface_estimator(self):
        table = None
        if self.exists('mica_surface.csv'):
            table = self.load('mica_surface.csv')
        return linear.Regression(table)
    def save_mica_surface_estimator(self, regression):
        table = ZenTable('mica_surface.csv')
        regression.save(table)
        self.save(table, 'mica_surface.csv')
    def delete_mica_surface_estimator(self):
        self.delete('mica_surface.csv')
    def store_registration_point_images(self):
        filename_pattern = os.path.join(self.folder, 'RegistrationPoints', 'Reg{0}.jpg')
        i = 0
        for reg in self.get_pois(type='r', suitability_function=all_points):
            i += 1
            self.drive_to_poi(reg)
            im = Zen.Acquisition.AcquireImage()
            cx = im.Bounds.SizeX / 2
            cy = im.Bounds.SizeY / 2
            arrow1 = im.Graphics.Add(ZenGraphicCategory.Arrow)
            arrow1.X1 = cx - 250
            arrow1.X2 = cx - 50
            arrow1.Y1 = cy
            arrow1.Y2 = cy
            arrow1.Thickness = 3
            arrow1.StrokeColor = ZenColors.Red
            arrow1.IsMeasurementVisible = False
            arrow1.RotationAngle = 0
            arrow2 = im.Graphics.Add(ZenGraphicCategory.Arrow)
            arrow2.X1 = cx
            arrow2.X2 = cx
            arrow2.Y1 = cy - 250
            arrow2.Y2 = cy - 50
            arrow2.Thickness = 3
            arrow2.StrokeColor = ZenColors.Red
            arrow2.IsMeasurementVisible = False
            arrow2.RotationAngle = 0
            im2 = im.BurnInGraphics()
            filename = filename_pattern.format(i)
            im2.Save(filename, 70)
            im.Close()
            im2.Close()
            reg.name = filename
        self.save_poi()


class AdjustPoiForm(AdjustForm):
    HARDWARE_SETTING = hs_transmitted
    CAMERA_SETTING = camera_setting
    def __init__(self, pois, docs):
        super(AdjustPoiForm, self).__init__(pois)
        self.docs = docs
        zen.set_hardware(self.HARDWARE_SETTING, self.CAMERA_SETTING)
    def drive(self, poi, count, total_count):
        self.docs.drive_to_poi(poi)
    def do_adjust(self, poi):
        (poi.x, poi.y, poi.z) = self.docs.stage_position()
    def do_mark(self, poi):
        poi.name = '# Unsuitable'

class AdjustMatrixForm(AdjustForm):
    OK = 'set to current position'
    LEAVE = 'ignore this point for now'
    MARK = 'mark this POI as unsuitable'
    EXIT = 'exit task'
    EXIT_KEEP = 'exit, ignoring remaining points'
    EXIT_MARK_ALL = 'exit and mark remaining POIs as unsuitable'
    HARDWARE_SETTING = hs_transmitted
    CAMERA_SETTING = camera_setting
    FLIP = 1
    def __init__(self, pois, docs):
        super(AdjustMatrixForm, self).__init__(pois)
        self.docs = docs
        self.adjustments = []
        zen.set_hardware(self.HARDWARE_SETTING, self.CAMERA_SETTING)
    def transform_point(self, x, y):
        return (x,y)
    def drive(self, poi, count, total_count):
        (x,y) = self.transform_point(poi.x, poi.y)
        self.docs.drive_to_xyz(x,y)
    def stage_position(self):
        (x,y,z) = self.docs.stage_position()
        return (x,y)
    def do_adjust(self, poi):
        (x,y) = self.stage_position()
        self.adjustments.append((x, y, poi.x, poi.y))
    def close(self):
        if 1 &lt; len(self.adjustments):
            self.set_matrix_function(linear.get_transformation(self.adjustments, self.FLIP))
        super(AdjustMatrixForm, self).close()

class AdjustMicaMatrixForm(AdjustMatrixForm):
    FLIP = -1
    def __init__(self, pois, docs, set_matrix_function):
        super(AdjustMicaMatrixForm, self).__init__(pois, docs)
        self.matrix_table = docs.matrix_table
        self.matrix = linear.table_to_matrix(self.matrix_table)
        self.set_matrix_function = set_matrix_function
        self.docs = docs
        self.focus_estimator = docs.load_mica_surface_estimator()
        self.backup_focus_estimator = None if self.focus_estimator.count() == 0 else linear.Regression()
        self.focussing_failures = 0
        self.savePois = False
    def transform_point(self, x, y):
        return linear.transform(self.matrix, x, y)
    def drive(self, poi, count, total_count):
        self.current_focus = Zen.Devices.Focus.ActualPosition
        self.docs.drive_to_poi(poi)
        grain = Zen.Acquisition.AcquireImage(False)
        mirror_grain = Zen.Processing.Transformation.Geometric.Mirror(
            grain,
            ZenMirrorMode.FlipHorizontal,
            ZenThirdProcessingDimension.None,
            False
        )
        rotated = Zen.Processing.Transformation.Geometric.Rotate2D(
            mirror_grain,
            ZenInterpolation.NearestNeighbour,
            self.docs.mica_angle(),
            False,
            False,
            False
        )
        mbounds = mirror_grain.Bounds
        rbounds = rotated.Bounds
        startX = (rbounds.SizeX - mbounds.SizeX) / 2
        startY = (rbounds.SizeY - mbounds.SizeY) / 2
        self.rotated_grain = rotated.CreateSubImage('X({0}-{1})|Y({2}-{3})'.format(
            startX,
            startX + mbounds.SizeX - 1,
            startY,
            startY + mbounds.SizeY - 1
        ))
        Zen.Application.Documents.Add(self.rotated_grain)
        zen.show_live()
        super(AdjustMicaMatrixForm, self).drive(poi, count, total_count)
        micaZ = poi.micaZ
        if micaZ is not None:
            self.current_focus = micaZ
        elif 3 &lt;= self.focus_estimator.count():
            self.current_focus = self.focus_estimator.estimate_z(
                Zen.Devices.Stage.ActualPositionX,
                Zen.Devices.Stage.ActualPositionY
            )
        zen.set_focus(self.current_focus)
    def undrive(self, poi):
        self.rotated_grain.Close()
        self.rotated_grain = None
    def do_adjust(self, poi):
        self.savePois = True
        super(AdjustMicaMatrixForm, self).do_adjust(poi)
        x = Zen.Devices.Stage.ActualPositionX
        y = Zen.Devices.Stage.ActualPositionY
        z = Zen.Devices.Focus.ActualPosition
        poi.micaZ = z
        self.focus_estimator.add(x, y, z)
        if self.backup_focus_estimator is not None:
            self.backup_focus_estimator.add(x, y, z)
        if (
            self.current_focus is not None
            and self.backup_focus_estimator is not None
            and 15 &lt; abs(self.current_focus - z)
        ):
            self.focussing_failures += 1
            if 3 &lt;= self.focussing_failures:
                # Throw away previous surface information, it wasn't working
                self.focus_estimator = self.backup_focus_estimator
                self.backup_focus_estimator = None
    def do_mark(self, poi):
        poi.name = '# Unsuitable'
        self.savePois = True
    def unmark_all(self):
        self.savePois = False
    def close(self):
        if self.savePois:
            self.docs.save_poi()
        self.docs.save_mica_surface_estimator(self.focus_estimator)
        super(AdjustMicaMatrixForm, self).close()

class ReRegisterPointsForm(AdjustMatrixForm):
    MARK = None
    def __init__(self, pois, docs, set_matrix_function):
        super(ReRegisterPointsForm, self).__init__(pois, docs)
        self.reg_image = PictureBox()
        self.layout.Controls.Add(self.reg_image, 0, 1)
        self.layout.SetColumnSpan(self.reg_image, 2)
        self.reg_image.Visible = False
        self.reg_image.WaitOnLoad = False
        self.reg_image.SizeMode = PictureBoxSizeMode.StretchImage
        self.reg_image.Width = 400
        self.reg_image.Height = 300
        self.matrix = docs.current_matrix
        self.set_matrix_function = set_matrix_function
    def get_exit_action(self):
        return self.EXIT_KEEP
    def drive(self, poi, count, total_count):
        self.docs.drive_to_poi(poi)
        if poi.name:
            self.reg_image.LoadAsync(poi.name)
            self.reg_image.Visible = True
        else:
            self.reg_image.Visible = False
    def stage_position(self):
        return (
            Zen.Devices.Stage.ActualPositionX,
            Zen.Devices.Stage.ActualPositionY
        )
    def transform_point(self, x, y):
        if not self.matrix:
            return (x,y)
        return linear.transform(self.matrix, x, y)
    def do_mark(self):
        raise NotImplementedError()

class AddPointForm(SelectForm):
    NO = 'No, stop adding points'
    def __init__(self, docs):
        super(AddPointForm, self).__init__(
            self.TITLE,
            self.LABEL,
            [self.YES, self.NO]
        )
        self.docs = docs
        self.count = self.initial_count()
    def initial_count(self):
        ps = self.docs.get_pois(self.TYPE, suitability_function=all_points)
        return count(ps)
    def action(self):
        n = self.count + 1
        Zen.Application.Pause('Find a new point ({0})'.format(n))
        if self.result() == self.YES:
            self.count = n
            return True
        return False
    def run(self):
        zen.show_live()
        self.show()
        while self.action():
            (x,y,z) = self.docs.stage_position()
            self.docs.poi.Rows.Add(self.TYPE, x, y, z, '')
        return self.count
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

class AddPoiForm(AddPointForm):
    TITLE = 'Add new POIs'
    LABEL = 'Should we add a new POI at this location?'
    YES = 'Yes, add this location as a new POI'
    TYPE = 'i'

class AddRegistrationPointsForm(AddPointForm):
    TITLE = 'Add new registration points'
    LABEL = 'Should we add a new registration point at this location?'
    YES = 'Yes, add this location as a new point'
    TYPE = 'r'

class AddMineralExtentsForm(AddPointForm):
    TITLE = 'Add new minerals extents'
    LABEL = 'Should we add this point to the mineral extents?'
    YES = 'Yes, add this location as a new mineral extent'
    TYPE = 'x'

class AddMicaExtentsForm(AddPointForm):
    TITLE = 'Add new mica extents'
    LABEL = 'Should we add this point to the mica extents?'
    YES = 'Yes, add this location as a new mica extent'
    TYPE = 'm'

class ResurrectUnsuitableForm(AdjustForm):
    OK = None
    LEAVE = 'leave as unsuitable'
    MARK = 'resurrect as suitable'
    CHANGE = None
    EXIT_CANCEL = "don't exit, carry on unmarking!"
    EXIT_KEEP = 'exit, leaving remaining POIs as they are'
    EXIT_MARK_ALL = 'exit and resurrect remaining POIs as suitable'
    EXIT_KEEP_ALL = 'exit, leaving all points as they were'
    TITLE = 'Choose what should happen to this POI'
    LABEL = 'What should we do with this POI?'
    def __init__(self, pois, docs):
        super(ResurrectUnsuitableForm, self).__init__(pois)
        self.docs = docs
        self.unmarked_count = 0
    def get_prompt(self, count, total, kept):
        return 'Resurrect point? ({0} of {1})'.format(count, total)
    def drive(self, o, count, total_count):
        self.docs.drive_to_poi(o)
    def do_adjust(self, o):
        raise NotImplementedError()
    def do_mark(self, poi):
        poi.name = ''
        self.unmarked_count += 1
    def unmark_all(self):
        self.unmarked_count = 0
    def close(self):
        if 0 &lt; self.unmarked_count:
            self.docs.save_poi()
        super(ResurrectUnsuitableForm, self).close()

class ResurrectUnsuitableWithMicaForm(ResurrectUnsuitableForm):
    CHANGE = 'swap mineral/mica'
    def do_drive(self, o, at_mica, count, total_count):
        if at_mica:
            self.docs.drive_to_poi_mica(o)
        else:
            self.docs.drive_to_poi(o)
    def drive(self, o, count, total_count):
        self.at_mica = False
        self.current = o
        self.count
        self.do_drive(o, self.at_mica, count, total_count)
    def change(self, o, count, total_count):
        self.at_mica = not self.at_mica
        self.do_drive(o, self.at_mica, count, total_count)

def has_at_least(seq, n):
    for s in seq:
        n -= 1
        if n &lt;= 0:
            return True
    return False

def count(seq):
    n = 0
    for s in seq:
        n += 1
    return n

class Task(object):
    def __init__(self, docs):
        self.docs = docs
    def name(self):
        raise NotImplementedError()
    def is_available(self):
        return True
    def recommended(self):
        return False
    def do(self):
        raise NotImplementedError()

class RefreshTask(Task):
    def name(self):
        return 'Refresh task list'
    def do(self):
        pass

class PointTask(Task):
    SAVE_MESSAGE = 'Save changes to points?'
    def save(self):
        self.docs.save_poi()
    def do(self):
        count = self.adjust_points()
        if count == 0:
            return
        window = Zen.Windows.CreateWindow(self.SAVE_MESSAGE)
        window.HasCancelButton = True
        if not window.Show().HasCanceled:
            self.save()

class AddPointsTask(PointTask):
    DONE_IS_SUITABLE = False
    MIN_POINTS = 1
    FORM = AddPoiForm
    def adjust_points(self):
        with self.FORM(self.docs) as form:
            return form.run()
    def recommended(self):
        sf = suitable_and_not_done
        if self.DONE_IS_SUITABLE:
            sf = suitable
        pois = self.docs.get_pois(
            type=self.FORM.TYPE,
            suitability_function=sf
        )
        return not has_at_least(pois, self.MIN_POINTS)

class AdjustPointsTask(PointTask):
    DONE_IS_SUITABLE = False
    def get_pois(self):
        sf = suitable_and_not_done
        if self.DONE_IS_SUITABLE:
            sf = suitable
        return self.docs.get_pois(
            type=self.POI_TYPE,
            suitability_function= sf 
        )
    def is_available(self):
        return has_at_least(self.get_pois(), 1)
    def adjust_points(self):
        with AdjustPoiForm(self.get_pois(), self.docs) as form:
            return form.run()

class AddPoisTask(AddPointsTask):
    SAVE_MESSAGE = 'Save new POIs?'
    def name(self):
        return 'Add POIs'
    def recommended(self):
        # Manimal should usually be used, not this task
        return False

class AdjustPoisTask(AdjustPointsTask):
    SAVE_MESSAGE = 'Save changes to POIs?'
    POI_TYPE = 'i'
    def name(self):
        return 'Adjust existing POIs'

class AddRegistrationPointsTask(AddPointsTask):
    MIN_POINTS = 2
    SAVE_MESSAGE = 'Save new registration points?'
    FORM = AddRegistrationPointsForm
    DONE_IS_SUITABLE = True
    def name(self):
        return 'Add registration points'
    def save(self):
        super(AddRegistrationPointsTask, self).save()
        self.docs.store_registration_point_images()

class AdjustRegistrationPointsTask(AdjustPointsTask):
    SAVE_MESSAGE = 'Save changes to registration points (does not re-register the slide)?'
    POI_TYPE = 'r'
    DONE_IS_SUITABLE = True
    def name(self):
        return 'Adjust registration points'
    def save(self):
        super(AdjustRegistrationPointsTask, self).save()
        self.docs.store_registration_point_images()

class AddMineralExtentsTask(AddPointsTask):
    MIN_POINTS = 2
    SAVE_MESSAGE = 'Save new mineral extents?'
    FORM = AddMineralExtentsForm
    def name(self):
        return 'Add mineral extents'

class AdjustMineralExtentsTask(AdjustPointsTask):
    SAVE_MESSAGE = 'Save changes to mineral extents?'
    POI_TYPE = 'x'
    def name(self):
        return 'Adjust existing mineral extents'

class AddMicaExtentsTask(AddPointsTask):
    MIN_POINTS = 2
    SAVE_MESSAGE = 'Save new mica extents?'
    FORM = AddMicaExtentsForm
    def name(self):
        return 'Add mica extents'

class AdjustMicaExtentsTask(AdjustPointsTask):
    SAVE_MESSAGE = 'Save changes to mica extents?'
    POI_TYPE = 'm'
    def name(self):
        return 'Adjust existing mica extents'

def current_magnification():
    return Zen.Devices.ObjectiveChanger.GetMagnificationByPosition(Zen.Devices.ObjectiveChanger.ActualPosition)

def request_magnification(mag):
    if current_magnification() != mag:
        suffix = ' (remember to insert and set the condenser appropriately)'
        if (mag &lt; 10):
            suffix = ' (remember to remove the condenser)'
        Zen.Application.Pause('Please set the magnification to {0}x{1}'.format(mag, suffix))

class NeedFocusTask(Task):
    def get_pois(self):
        return self.docs.get_pois(self.POI_TYPE)
    def extent_from_pois(self, pois):
        ps = list(pois)
        (xmin, ymin) = self.docs.stage_position_of_poi(ps[0])
        xmax = xmin
        ymax = ymin
        z = ps[0].z
        for p in ps[1:]:
            (x, y) = self.docs.stage_position_of_poi(p)
            if x &lt; xmin:
                xmin = x
            elif xmax &lt; x:
                xmax = x
            if y &lt; ymin:
                ymin = y
            elif ymax &lt; y:
                ymax = y
            z += p.z
        return (xmin, xmax, ymin, ymax, z / len(ps))
    def get_focus_position(self):
        ps = self.get_pois()
        (xmin, xmax, ymin, ymax, z) = self.extent_from_pois(ps)
        return ((xmin + xmax) / 2, (ymin + ymax) / 2)
    def get_focused(self):
        (x, y) = self.get_focus_position()
        self.docs.drive_to_xyz(x, y)
        try:
            zen.autofocus(self.EXPERIMENT_NAME, 10)
        except Exception as e:
            zen.show_live(self.EXPERIMENT_NAME)
            Zen.Application.Pause('Autofocus failed, please focus manually then click Continue')

class CreateTiledImageTask(NeedFocusTask):
    REG_SIZE = 50
    MAGNIFICATION = 10
    def get_pois(self):
        return self.docs.get_pois(self.POI_TYPE)
    def get_extents(self):
        return [list(self.get_pois())]
    def is_available(self):
        return has_at_least(self.get_pois(), 2)
    def extra_points(self):
        return []
    def user_setup(self):
        request_magnification(self.MAGNIFICATION)
    def do(self):
        self.user_setup()
        self.get_focused()
        exp = Zen.Acquisition.Experiments.GetByFileName(self.EXPERIMENT_NAME)
        exp.ClearTileRegionsAndPositions(0)
        for ps in self.get_extents():
            (xmin, xmax, ymin, ymax, z) = self.extent_from_pois(ps)
            w = xmax - xmin
            h = ymax - ymin
            exp.AddRectangleTileRegion(0, xmin + w/2, ymin + h/2, w, h, z)
        for p in self.extra_points():
            (x, y) = self.docs.stage_position_of_poi(p)
            exp.AddRectangleTileRegion(0, x, y, self.REG_SIZE, self.REG_SIZE, p.z)
        tiles = Zen.Acquisition.Execute(exp)
        path = os.path.join(self.docs.folder, self.FILE_NAME)
        zen.save_as(tiles, path, True)
        tiles.Close()
        exp.ClearTileRegionsAndPositions(0)
        zen.discard_changes(exp)

class CreateMineralImageTask(CreateTiledImageTask):
    POI_TYPE = 'x'
    EXPERIMENT_NAME = tile_rl_experiment_name
    FILE_NAME = 'minerals.czi'
    EXPERIMENT_NAMES = {
        'reflected': tile_rl_experiment_name,
        'transmitted': tile_tl_experiment_name,
        'circularly polarized': tile_cpol_experiment_name
    }
    FILE_NAMES = {
        'reflected': 'mineralsRL.czi',
        'transmitted': 'mineralsTL.czi',
        'circularly polarized': 'mineralsCPol.czi'
    }
    def user_setup(self):
        super(CreateMineralImageTask, self).user_setup()
        window = Zen.Windows.CreateWindow('Select lighting')
        window.AddDropDown(
            'lighting', 'Lighting', self.EXPERIMENT_NAMES.keys(), 0
        )
        result = window.Show()
        if result.HasCanceled:
            raise UserCancelledException()
        lighting = result.GetValue('lighting')
        self.EXPERIMENT_NAME = self.EXPERIMENT_NAMES[lighting]
        self.FILE_NAME = self.FILE_NAMES[lighting]
    def name(self):
        return 'Generate minerals tiled image'
    def recommended(self):
        return not self.docs.has_minerals
    def extra_points(self):
        return self.docs.get_pois('r')

class CreateMicaImageTask(CreateTiledImageTask):
    POI_TYPE = 'm'
    EXPERIMENT_NAME = tile_tl_experiment_name
    FILE_NAME = 'mica.czi'
    def name(self):
        return 'Generate mica tiled image'
    def recommended(self):
        return not self.docs.has_mica

class RegistrationTask(Task):
    SAVE_MESSAGE = 'Reregister?'
    def set_matrix(self, matrix):
        raise NotImplementedError()
    def ask_to_set_matrix(self, matrix):
        window = Zen.Windows.CreateWindow(self.SAVE_MESSAGE)
        window.HasCancelButton = True
        if not window.Show().HasCanceled:
            self.set_matrix(matrix)

class AdjustMicaMatrixTask(RegistrationTask):
    SAVE_MESSAGE = 'Save changes to mica transformation?'
    def name(self):
        return 'Fine tune mica transformation'
    def get_pois(self):
        return self.docs.get_pois('i', suitable)
    def is_available(self):
        return has_at_least(self.get_pois(), 2) and self.docs.matrix
    def do(self):
        with AdjustMicaMatrixForm(self.get_pois(), self.docs, self.ask_to_set_matrix) as form:
            form.run()
    def set_matrix(self, matrix):
        mt = self.docs.matrix_table
        for r in range(2):
            for c in range(3):
                mt.SetValue(r, c, matrix[r][c])
        self.docs.save_matrix()

class ReRegisterPointsTask(RegistrationTask):
    SAVE_MESSAGE = 'Save this registration?'
    def name(self):
        return 'Re-register (after stage recalibration or slide removal)'
    def get_pois(self):
        return self.docs.get_pois('r', suitable)
    def is_available(self):
        return has_at_least(self.get_pois(), 2)
    def do(self):
        with ReRegisterPointsForm(self.get_pois(), self.docs, self.ask_to_set_matrix) as form:
            form.run()
    def set_matrix(self, matrix):
        mt = self.docs.get_current_matrix_table()
        for r in range(2):
            for c in range(3):
                mt.SetValue(r, c, matrix[r][c])
        self.docs.save_current_matrix()

class ResetRegistrationTask(RegistrationTask):
    SAVE_MESSAGE = 'Move all points to new registration (and delete old tiled images)?'
    def name(self):
        return 'Reset registration: move points and delete tiled images'
    def get_pois(self):
        return self.docs.get_pois('r')
    def is_available(self):
        return has_at_least(self.get_pois(), 2)
    def do(self):
        with ReRegisterPointsForm(self.get_pois(), self.docs, self.ask_to_set_matrix) as form:
            form.run()
    def set_matrix(self, matrix):
        for p in self.docs.all_pois():
            (x, y) = linear.transform(matrix, p.x, p.y)
            p.x = x
            p.y = y
        self.docs.save_poi()
        self.docs.delete_minerals()
        self.docs.delete_mica()
        self.docs.delete_current_matrix()

class ResurrectUnsuitableTask(Task):
    def name(self):
        return 'Resurrect unsuitable POIs as suitable'
    def get_pois(self):
        return self.docs.get_pois('i', suitability_function=unsuitable)
    def is_available(self):
        return has_at_least(self.get_pois(), 1) and not self.docs.matrix
    def do(self):
        with ResurrectUnsuitableForm(self.get_pois(), self.docs) as form:
            if form.run() == 0:
                return
        window = Zen.Windows.CreateWindow('Do you want to resurrect these points?')
        window.HasCancelButton = True
        if not window.Show().HasCanceled:
            self.docs.save_poi()

class ResurrectUnsuitableWithMicaTask(Task):
    def name(self):
        return 'Resurrect unsuitable POIs as suitable'
    def get_pois(self):
        return self.docs.get_pois('i', suitability_function=unsuitable)
    def is_available(self):
        return has_at_least(self.get_pois(), 1) and self.docs.matrix
    def do(self):
        with ResurrectUnsuitableWithMicaForm(self.get_pois(), self.docs) as form:
            if form.run() == 0:
                return
        window = Zen.Windows.CreateWindow('Do you want to resurrect these points?')
        window.HasCancelButton = True
        if not window.Show().HasCanceled:
            self.docs.save_poi()

class GetMicaMatrixTask(Task):
    def name(self):
        return 'Get mica transformation matrix (with Manimal)'
    def is_available(self):
        return self.docs.has_minerals and self.docs.has_mica
    def recommended(self):
        return not self.docs.matrix
    def do(self):
        proc = subprocess.Popen([
            'python',
            '-m',
            'manimal',
            '-m',
            'matrix.csv',
            '-f',
            'minerals*.czi',
            '-a',
            'mica.czi'
        ], cwd=self.docs.folder)
        proc.wait()

class ManimalPoiTask(Task):
    def name(self):
        return 'Add/adjust POIs and registration points (with Manimal)'
    def is_available(self):
        return self.docs.has_minerals
    def recommended(self):
        # if we have already started getting Z-stacks, we're probably
        # past the adding and adjusting stage
        for poi in self.docs.get_pois(suitability_function=suitable):
            if poi.name:
                return False
        return True
    def do(self):
        proc = subprocess.Popen([
            'python',
            '-m',
            'manimal',
            '-p',
            'poi.csv',
            '-f',
            'minerals*.czi',
            '--magsize',
            '250x200',
        ], cwd=self.docs.folder)
        proc.wait()

class MakeMapTask(CreateTiledImageTask):
    POI_TYPE = 'x'
    EXPERIMENT_NAME = map_experiment_name
    MAGNIFICATION = 5
    FILE_NAME = 'map.czi'
    def name(self):
        return 'Create annotated map of minerals'
    def is_available(self):
        pois = self.get_pois()
        return (
            has_at_least(pois, 2)
            and self.docs.has_minerals
        )
    def extra_points(self):
        if self.include_reg:
            return self.docs.get_pois('r')
        return []
    def get_extents(self):
        xs = list(self.get_pois())
        if self.include_mica:
            return [xs, list(self.docs.get_pois('m'))]
        else:
            return [xs]
    def do(self):
        window = Zen.Windows.CreateWindow('Make annotated map')
        window.AddCheckbox('annotation', 'Add annotations', True)
        window.AddIntegerRange('factor', 'Downsampling factor', 8, 2, 32)
        if has_at_least(self.docs.get_pois('r'), 1):
            window.AddCheckbox('include_reg', 'Include registration points in JPG', True)
        if self.docs.has_mica:
            window.AddCheckbox('include_mica', 'Include mica in JPG', False)
        window.AddCheckbox('flip', 'Flip image', True)
        result = window.Show()
        if result.HasCanceled:
            return None
        self.include_reg = result.Contains('include_reg') and result.GetValue('include_reg')
        self.include_mica = result.Contains('include_mica') and result.GetValue('include_mica')
        super(MakeMapTask, self).do()
        params = [
            'python',
            '-m',
            'czi2jpg',
            '-a',
            'poi.csv',
            '-d',
            str(result.GetValue('factor'))
        ]
        current_matrix = self.docs.maybe_current_matrix()
        if current_matrix:
            params.append('-r')
            params.append(current_matrix)
        if result.GetValue('flip'):
            params.append('-f')
        params.append(self.FILE_NAME)
        output_name = 'map.jpg'
        params.append(output_name)
        proc = subprocess.Popen(params, cwd=self.docs.folder)
        proc.wait()
        path = os.path.join(self.docs.folder, output_name)
        old_image = Zen.Application.Documents.GetByFileName(path)
        if old_image:
            old_image.Close()
        image = Zen.Application.LoadImage(path)
        Zen.Application.Documents.Add(image)

def acquire_stack(parameters, folder, prefix=''):
    rl_slice_start = -parameters['rl_slice_above']
    rl_slice_end = parameters['rl_slice_below']
    rl_interval = parameters['rl_interval']
    tl_slice_start = -parameters['tl_slice_above']
    tl_slice_end = parameters['tl_slice_below']
    tl_interval = parameters['tl_interval']
    focus = Zen.Devices.Focus.ActualPosition
    zen.set_hardware(camera_setting=camera_setting)
    zen.set_hardware(hs_reflected, camera_setting)
    for i in range(rl_slice_start, rl_slice_end):
        Zen.Devices.Focus.MoveTo(focus + i * rl_interval)
        im = Zen.Acquisition.AcquireImage()
        im.Save(os.path.join(folder, "{1}ReflStack-{0:02d}.jpg".format(i, prefix)), 80)
    zen.set_hardware(hs_transmitted, camera_setting)
    for i in range(tl_slice_start, tl_slice_end):
        Zen.Devices.Focus.MoveTo(focus + i * tl_interval)
        im = Zen.Acquisition.AcquireImage()
        im.Save(os.path.join(folder, "{1}Stack-{0:02d}.jpg".format(i, prefix)), 80)
    Zen.Devices.Focus.MoveTo(focus)

def get_parameters(tl_interval, tl_slice_above, tl_slice_below, rl_interval, rl_slice_above, rl_slice_below):
    window = Zen.Windows.CreateWindow('Acquire image stacks')
    window.AddDoubleRange('tl_interval', 'Focus interval (transmitted light, microns)', tl_interval, 0.1, 2.0)
    window.AddIntegerRange('tl_slice_above', 'Number of slices above found focus in Z-stack (transmitted light)', tl_slice_above, 0, 10)
    window.AddIntegerRange('tl_slice_below', 'Number of slices at or below found focus in Z-stack (transmitted light)', tl_slice_below, 0, 30)
    window.AddDoubleRange('rl_interval', 'Focus interval (reflected light, microns)', rl_interval, 0.1, 2.0)
    window.AddIntegerRange('rl_slice_above', 'Number of slices above found focus in Z-stack (reflected light)', rl_slice_above, 0, 10)
    window.AddIntegerRange('rl_slice_below', 'Number of slices at or below found focus in Z-stack (reflected light)', rl_slice_below, 0, 10)
    window.AddTextBlock('Please select the 50x objective, set the condensor and set the transmitted light filters to 6,100')
    result = window.Show()
    if result.HasCanceled:
        return None
    r = {}
    for k in [
        'tl_interval',
        'tl_slice_above',
        'tl_slice_below',
        'rl_interval',
        'rl_slice_above',
        'rl_slice_below'
    ]:
        r[k] = result.GetValue(k)
    return r

class CaptureZStacksTask(NeedFocusTask):
    FILE_PREFIX = ''
    MAX_FAILURES = 3
    EXPERIMENT_NAME = coarse_focus_experiment_name
    FINE_FOCUS_EXPERIMENT_NAME = fine_focus_experiment_name
    def poi_is_ok(self, poi):
        return True
    def get_pois(self):
        return [
            p
            for p in self.docs.get_pois('i', suitability_function=suitable)
            if self.poi_is_ok(p)
        ]
    def get_focus_position(self):
        ps = self.get_pois()
        p = ps[0]
        return (p.x, p.y)
    def is_available(self):
        return has_at_least(self.get_pois(), 1)
    def recommended(self):
        return True
    def focus(self, poi):
        zen.autofocus(self.EXPERIMENT_NAME)
        zen.autofocus(self.FINE_FOCUS_EXPERIMENT_NAME)
    def drive_to(self, poi):
        self.docs.drive_to_poi(poi)
    def get_folder(self, poi):
        raise NotImplementedError()
    def set_folder(self, poi, folder):
        pass
    def preprocess_pois(self, pois):
        pass
    def too_many_failures(self):
        pass
    def do(self):
        parameters = get_parameters(0.3, 5, 17, 1.0, 3, 3)
        if not parameters:
            return
        request_magnification(50)
        c = 0
        failures = 0
        pois = list(self.get_pois())
        self.preprocess_pois(pois)
        self.get_focused()
        with ProgressOutput(len(pois)) as progress:
            for poi in pois:
                self.drive_to(poi)
                c += 1
                print('capturing {0} out of {1} POIs (row {2}) at {3}'.format(
                    c, len(pois), poi.table_row + 1, time.strftime('%H:%M:%S', time.localtime())
                ))
                success = False
                try:
                    grain_folder = self.get_folder(poi)
                    if grain_folder:
                        progress.start(grain_folder)
                        self.focus(poi)
                        acquire_stack(parameters, grain_folder, self.FILE_PREFIX)
                        self.docs.save_current_matrix_as(os.path.join(
                            grain_folder, self.REGISTRATION_MATRIX_FILE_NAME
                        ))
                        self.set_folder(poi, grain_folder)
                        success = True
                except Exception as e:
                    print e
                    print type(e)
                    failures += 1
                    if failures == self.MAX_FAILURES:
                        Zen.Application.Pause(self.FAILURE_MESSAGE)
                        self.too_many_failures()
                        return
                progress.stop(success)
            if failures != 0:
                Zen.Application.Pause('Finished, but with {0} failures'.format(failures))

class CaptureMineralZStacksTask(CaptureZStacksTask):
    REGISTRATION_MATRIX_FILE_NAME = 'mineral_matrix.csv'
    FAILURE_MESSAGE = 'Too many failures! Try running the Adjust existing POIs task'
    def name(self):
        return 'Capture Mineral Z-Stacks'
    def poi_is_ok(self, poi):
        if not poi.name:
            return True
        if poi.name[0] == '#':
            return False
        mineral = os.path.join(poi.name, 'Stack-00.jpg')
        return not os.path.exists(mineral)
    def get_folder(self, poi):
        return self.docs.get_next_grain_folder()
    def set_folder(self, poi, folder):
        poi.name = folder
        self.docs.save_poi()
    def preprocess_pois(self, pois):
        """
        Remove all the existing folder names, otherwise we might confuse ourselves
        by putting the z-stack for one poi in the name another poi already thinks
        it owns.
        """
        for poi in pois:
            poi.name = ''

class CaptureMicaZStacksTask(CaptureZStacksTask):
    REGISTRATION_MATRIX_FILE_NAME = 'mica_matrix.csv'
    FILE_PREFIX = 'Mica'
    FAILURE_MESSAGE = 'Too many failures! Please try again'
    EXPERIMENT_NAME = coarse_focus_experiment_name
    def __init__(self, docs):
        super(CaptureMicaZStacksTask, self).__init__(docs)
        self.focus_estimator = docs.load_mica_surface_estimator()
    def name(self):
        return 'Capture Mica Z-Stacks for existing Mineral Z-Stacks'
    def poi_is_ok(self, poi):
        if poi.name and poi.name[0] != '#':
            mineral = os.path.join(poi.name, 'Stack-00.jpg')
            mica = os.path.join(poi.name, 'MicaStack-00.jpg')
            if os.path.exists(mineral) and not os.path.exists(mica):
                return True
        return False
    def focus(self, poi):
        micaZ =  poi.micaZ
        if micaZ is not None:
            zen.set_focus(micaZ)
            zen.autofocus(fine_focus_experiment_name)
        elif self.focus_estimator.count() &lt; 3:
            Zen.Application.Pause('Please focus manually')
            self.focus_estimator.add(
                Zen.Devices.Stage.ActualPositionX,
                Zen.Devices.Stage.ActualPositionY,
                Zen.Devices.Focus.ActualPosition
            )
        else:
            z = self.focus_estimator.estimate_z(
                Zen.Devices.Stage.ActualPositionX,
                Zen.Devices.Stage.ActualPositionY
            )
            Zen.Devices.Focus.MoveTo(z)
            zen.autofocus(fine_focus_experiment_name)
            self.focus_estimator.add(
                Zen.Devices.Stage.ActualPositionX,
                Zen.Devices.Stage.ActualPositionY,
                Zen.Devices.Focus.ActualPosition
            )
    def drive_to(self, poi):
        self.docs.drive_to_poi_mica(poi)
    def get_focused(self):
        pass
    def too_many_failures(self):
        success_count = self.focus_estimator.count()
        if success_count &lt;= 3 + self.MAX_FAILURES:
            # You get three successes for free. If your extra successes
            # don't outnumber your failures, it's probably a good idea
            # to throw away the current failing surface estimator
            self.docs.delete_mica_surface_estimator()
    def get_folder(self, poi):
        return poi.name

def get_project_folder():
    window = Zen.Windows.CreateWindow('Choose folder to work in')
    documents_folder = Zen.Application.Environment.GetFolderPath(ZenSpecialFolder.Documents)
    folder = os.path.join(documents_folder, 'GeochronAtHome')
    window.AddFolderBrowser('folder','Output folder', folder)
    window.FocusControl = 'folder'
    result = zen.show_window(window)
    return result.GetValue('folder')

def run_a_task(folder):
    docs = Documents(folder)
    task_classes = [
        AddRegistrationPointsTask,
        AdjustRegistrationPointsTask,
        AddPoisTask,
        AdjustPoisTask,
        AddMineralExtentsTask,
        AdjustMineralExtentsTask,
        AddMicaExtentsTask,
        AdjustMicaExtentsTask,
        CreateMineralImageTask,
        CreateMicaImageTask,
        AdjustMicaMatrixTask,
        ReRegisterPointsTask,
        ResetRegistrationTask,
        ResurrectUnsuitableTask,
        ResurrectUnsuitableWithMicaTask,
        GetMicaMatrixTask,
        ManimalPoiTask,
        CaptureMineralZStacksTask,
        CaptureMicaZStacksTask,
        MakeMapTask,
        RefreshTask,
    ]
    tasks = {}
    dones = []
    news = []
    for t in [ tc(docs) for tc in task_classes ]:
        if t.is_available():
            name = t.name()
            if t.recommended():
                name = '* ' + name
                tasks[name] = t
                news.append(name)
            else:
                tasks[name] = t
                dones.append(name)
    window = Zen.Windows.CreateWindow('Choose a task')
    window.AddDropDown('task', 'Task', news + dones, 0)
    r = window.Show()
    if r.HasCanceled:
        return False
    try:
        tasks[r.GetValue('task')].do()
    except UserCancelledException:
        pass
    return True

folder = get_project_folder()
while run_a_task(folder):
    pass
</Text>
  <Author></Author>
  <Description></Description>
  <Keywords></Keywords>
  <Row>72</Row>
  <Column>24</Column>
</Script>